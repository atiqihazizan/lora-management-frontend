import React, { useRef, useState, useEffect } from "react";
import { FaLocationCrosshairs, FaPlus, FaMinus } from "react-icons/fa6";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { MapContainer, TileLayer } from "react-leaflet";
import { useMapState } from "../context/MapContext";
import L, { marker } from 'leaflet';
import "leaflet/dist/leaflet.css";
import 'leaflet-routing-machine';
import 'leaflet-routing-machine/dist/leaflet-routing-machine.css';
import DroppableAdded from "./DroppableAdded";
import DroppableMarker from "./DroppableMarker";
import apiClient from "../utils/apiClient";
import PropTypes from 'prop-types';

const MapPlayBack = ({ id, mapview, tiles, track }) => {
  const { tileLayer, setTileLayer, markers } = useMapState();
  const mainMapRef = useRef()
  const queryClient = useQueryClient();

  const findDefaultTileIndex = () => {
    if (mapview?.tile_url) {
      const index = tiles.findIndex((tile) => tile.url === mapview.tile_url);
      return index !== -1 ? index : 0; // Jika ditemukan, gunakan index, jika tidak gunakan 0
    }
    return 0; // Default ke 0 jika tile_url null
  };

  const [currentTileIndex, setCurrentTileIndex] = useState(findDefaultTileIndex);

  // Mengatur ikon default Leaflet secara manual
  delete L.Icon.Default.prototype._getIconUrl;

  L.Icon.Default.mergeOptions({
    iconRetinaUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png',
    iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
    shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
  });

  useEffect(() => { setCurrentTileIndex(findDefaultTileIndex()) }, [mapview, tiles]);

  // Fungsi untuk menyimpan perubahan tile layer ke database
  const saveTileLayerToDB = useMutation({
    mutationFn: async (data) => {
      const result = await apiClient.put(`/mapview/tilelayer/${id}`, { tile_url: data });
      return { result, data: data };
    },
    onSuccess: () => {
      queryClient.invalidateQueries(['mapview']);
      // queryClient.removeQueries(['mapview']);
    },
  });

  // Fungsi untuk menangani toggle tile layer pada minimap
  const handleMinimapClick = () => {
    const nextIndex = (currentTileIndex + 1) % tiles.length; // Hitung indeks tile berikutnya
    const nextTileLayer = tiles[nextIndex].url; // URL tile berikutnya
    setCurrentTileIndex(nextIndex); // Perbarui currentTileIndex
    setTileLayer(nextTileLayer); // Set tile layer di main map
    saveTileLayerToDB.mutateAsync(nextTileLayer); // Simpan perubahan tile layer ke database
  };

  // Fungsi untuk mengembalikan pusat peta ke koordinat asal
  const handleCenterButtonClick = () => {
    if (mainMapRef.current) {
      mainMapRef.current.setView(mapview.latlng, mapview.zoom);
    }
  };

  const nextTileIndex = (currentTileIndex + 1) % tiles.length; // Indeks tile untuk minimap
  useEffect(() => {
    const timer = setTimeout(() => {
      if (mainMapRef.current && track?.length > 1) {
        mainMapRef.current.invalidateSize();
        const waypoints = track.map(point => [point.location_lat, point.location_lon]);

        L.polyline(waypoints, { color: 'blue', weight: 3 }).addTo(mainMapRef.current);


        // const map = mainMapRef.current;
        // const len = track.length - 2
        // const routingControl = L.Routing.control({
        //   waypoints: [
        //     L.latLng(track[0].location_lat, track[0].location_lon),
        //     L.latLng(track[len].location_lat, track[len].location_lon),
        //   ],
        //   // routeWhileDragging: false,
        //   show: false,
        //   // addWaypoints: true,
        //   // createMarker: function (i, waypoint) {
        //   //   if (i === 0 || i === track.length - 1) {
        //   //     return L.marker(waypoint.latLng);
        //   //   }
        //   //   return null;
        //   // },
        // })
        //   .on('routesfound', e => {
        //     const animatedMarker = L.marker([track[0].location_lat, track[0].location_lon]).addTo(map);
        //     e.routes[0].coordinates.forEach((coor, index) => {
        //       setTimeout(() => animatedMarker.setLatLng([coor.lat, coor.lng]), 100 * index)
        //     });
        //   })
        //   .on('routingerror', function (e) {
        //     console.error('Routing error:', e);
        //     alert('Routing failed. Please try again later.');
        //   })
        //   .addTo(map);

        // return () => {
        //   map.removeControl(routingControl);
        // };
      }
    }, 500); // Delay 100 ms

    return () => clearTimeout(timer);
  }, [mainMapRef, track]);

  // useEffect(() => {
  //   const timer = setTimeout(() => {
  //     if (mainMapRef.current && track?.length > 1) {
  //       const map = mainMapRef.current;

  //       // Buat marker pertama di titik awal
  //       const animatedMarker = L.marker([track[0].location_lat, track[0].location_lon]).addTo(map);

  //       // Animasi marker mengikuti koordinat rute
  //       track.forEach((point, index) => {
  //         const animatedMarker = L.marker([point.location_lat, point.location_lon]).addTo(map);

  //         // setTimeout(() => {
  //         //   animatedMarker.setLatLng([point.location_lat, point.location_lon]); // Pindahkan marker
  //         // }, 100 * index); // Animasi setiap 500 ms
  //       });

  //       return () => {
  //         map.removeLayer(animatedMarker); // Hapus marker saat komponen dilepas
  //       };
  //     }
  //   }, 100); // Delay 100 ms

  //   return () => clearTimeout(timer);
  // }, [mainMapRef, track]);


  if (!tiles) return <></>

  return (
    <div className="relative h-full w-full">
      {/* Peta utama */}
      <MapContainer
        className="h-full w-full flex-1 mainmap"
        ref={mainMapRef}
        center={mapview.latlng}
        zoom={mapview.zoom}
        // whenCreated={(mapInstance) => setMainMapRef(mapInstance)}
        attributionControl={false}
        zoomControl={false}
      >
        <TileLayer url={tileLayer || tiles?.[currentTileIndex]?.url} />
        <DroppableAdded accept="point" mapid={id} />
        {markers.map((marker, key) => (
          <DroppableMarker key={key} marker={marker} accept="feat" />
        ))}
      </MapContainer>

      {/* Minimap sebagai tombol toggle */}
      <div className="minimap-container" onClick={handleMinimapClick}>
        <MapContainer
          center={mapview.latlng}
          zoom={10}
          className="minimap"
          dragging={false}
          zoomControl={false}
          scrollWheelZoom={false}
          doubleClickZoom={false}
          attributionControl={false}
        >
          <TileLayer url={tiles?.[nextTileIndex]?.url || tiles?.[0]?.url} />
        </MapContainer>
        <div className={`minimap-label `}>
          {tiles?.[nextTileIndex]?.name || 'Default'}
        </div>
      </div>

      {/* Tombol zoom di sudut kanan bawah */}
      <div className="btn-zoom bottom-[10px] overflow-hidden">
        <button
          className="btn-zoom-content border-b border-gray-300"
          onClick={() => mainMapRef.current && mainMapRef.current.zoomIn()}
        >
          <FaPlus className="h-3 w-3 text-gray-600" />
        </button>
        <button
          className="btn-zoom-content"
          onClick={() => mainMapRef.current && mainMapRef.current.zoomOut()}
        >
          <FaMinus className="h-3 w-3 text-gray-600" />
        </button>
      </div>

      <button className="btn-location-center" onClick={handleCenterButtonClick} >
        <FaLocationCrosshairs className="h-4 w-4 text-gray-600" />
      </button>
    </div>
  );
};

MapPlayBack.propTypes = {
  id: PropTypes.string.isRequired,
  mapview: PropTypes.object.isRequired,
  tiles: PropTypes.arrayOf(
    PropTypes.shape({
      url: PropTypes.string.isRequired,
      name: PropTypes.string.isRequired,
      theme: PropTypes.oneOf(['light', 'dark']).isRequired,
    })
  ).isRequired,
  track: PropTypes.array,
};

export default React.memo(MapPlayBack);
